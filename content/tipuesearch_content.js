var tipuesearch = {"pages": [{'title': 'About', 'text': '\n .. \n', 'tags': '', 'url': 'About.html'}, {'title': 'About me 40823124.', 'text': '\n', 'tags': '', 'url': 'About me 40823124..html'}, {'title': 'Team project', 'text': '', 'tags': '', 'url': 'Team project.html'}, {'title': 'Team1 W2', 'text': 'design a ladder that can move up and down \n \n', 'tags': '', 'url': 'Team1 W2.html'}, {'title': 'Team1 W3', 'text': "Founded that the ladder was too complicated and not feasible in a short time, so changed it to a tank. \n \n control the rotation of the turret \n \n  wheel \n threadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==2007) then\n                    -- up key\n                    velocity=1\n                    torque=2\n                    hammer_back = 0\n\n                    \n                end\n                if (auxiliaryData[1]==2008) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-2\n                     velocity = -1\n\n                end\n               \n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired top position:\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointForce(joint,torque)\n        \n        -- Since this script is threaded, don't waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle('joint1'),sim.getObjectHandle('joint3')\nhammer=sim.getObjectHandle('weel1'),sim.getObjectHandle('weel3')\nvelocity=0\nhammer_back=0\ntorque=0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer,-1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage('Lua runtime error: '..err)\nend\n \n-- Put some clean-up code here:\n\n \n turret \n threadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==97) then\n                    -- a key\n                    velocity=0.01\n                    torque=0.02\n                    hammer_back = 0\n\n                    \n                end\n                if (auxiliaryData[1]==100) then\n                    -- d key\n                     hammer_back = 1\n                     torque=-0.02\n                     velocity = -0.01\n\n                end\n               \n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired top position:\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointForce(joint,torque)\n        \n        -- Since this script is threaded, don't waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle('joint0')\nhammer=sim.getObjectHandle('top')\nvelocity=0\nhammer_back=0\ntorque=0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer,-1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage('Lua runtime error: '..err)\nend\n \n-- Put some clean-up code here:\n\nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==97) then\n                    -- a key\n                    velocity=0.01\n                    torque=0.02\n                    hammer_back = 0\n\n                    \n                end\n                if (auxiliaryData[1]==100) then\n                    -- d key\n                     hammer_back = 1\n                     torque=-0.02\n                     velocity = -0.01\n\n                end\n               \n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired top position:\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointForce(joint,torque)\n        \n        -- Since this script is threaded, don't waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle('joint0')\nhammer=sim.getObjectHandle('top')\nvelocity=0\nhammer_back=0\ntorque=0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer,-1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage('Lua runtime error: '..err)\nend\n \n-- Put some clean-up code here:\n\n \n", 'tags': '', 'url': 'Team1 W3.html'}, {'title': 'Team 2', 'text': "Programming control mechanicalarm \n Used lua api to contral mechanical arm in CoppeliaSim \n \n \n I edited all joints separately \n \n \n This is the parameter of the joint \n \n threadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==97) then\n                    -- d key\n                    if(o < i*10) then\n                    o = o+i\n                    velocity=velocity+0.11\n                    torque=torque+0.1\n                    hammer_back = 0\n                    end\n                end\n                if (auxiliaryData[1]==100) then\n                    -- a key \n                    if(o > -i*10) then\n                    o = o-i\n                    velocity=velocity-0.11\n                    torque=torque-0.1\n                    hammer_back = 1\n                    end\n                end\n                \n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then \n               sim.setJointPosition(joint, -1, orientation)\n               --sim.setObjectPosition(hammer,-1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        --sim.setJointForce(joint,torque)\n\n        -- Since this script is threaded, don't waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\ni = 1\no = i*1\njoint=sim.getObjectHandle('redundantRob_joint1')\nhammer=sim.getObjectHandle('Rectangle')\nvelocity=0\nhammer_back=0\ntorque=0\nsliding = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer,-1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage('Lua runtime error: '..err)\nend\n \n-- Put some clean-up code here:\n \n", 'tags': '', 'url': 'Team 2.html'}, {'title': 'Difficulties and debugging', 'text': '在控制關節時因為每個關節所設置的位置與阻尼參數不同，會有抖動的情形發生，基本上把所有的參數都設成一樣的並把馬達改成控制模式就好了。 \n \n 再來是程式的部分，因為每個關節都是用速度去控制轉動的，所以為了避免互相影響把每個關節分開單獨用一個子模組控制，而其中設置了轉動條件，限制轉動的次數，且設置了兩個參數控制互鎖，並用自身相加方式達成可以重複接收訊號。 \n \n 另外在關節2的部分因為承受整隻手臂的絕大重量，所以轉動到了一定角度後會因為自身重量而倒下，所以在關節與程式皆有限制轉動的角度跟輸入次數，當按下按鍵一定次數後必須往反方向轉動，否則互鎖。 \n \n 參考鍵盤ASCII控制字符 \n \n', 'tags': '', 'url': 'Difficulties and debugging.html'}, {'title': 'Team 3', 'text': '', 'tags': '', 'url': 'Team 3.html'}, {'title': 'RoboDK', 'text': 'RoboDK的執行檔在bin目錄下 \n \xa0 \n 執行API前需安裝pip \n \n error \n 其中一個函示庫無法找到 \n \n', 'tags': '', 'url': 'RoboDK.html'}, {'title': 'MTB_robot', 'text': '嘗試找出plugin的部分 \n', 'tags': '', 'url': 'MTB_robot.html'}, {'title': 'coppeliasim', 'text': '', 'tags': '', 'url': 'coppeliasim.html'}, {'title': 'RemoteApi', 'text': 'I try to make a remoteapi(python) of coppeliasim to control the example of robot But it just start simulation, and I cannot control the movement of the model as I set it up. \n \n To use the remote API functionality in python script, need following 3 items: sim.py simConst.py remoteApi.dill ,it can ce found in coppeliasim->programming->remoteapibindings->python , just put all of then in to a same folder. \n \n code \n from __future__ import division\nimport numpy as np\nimport math\nimport sim\n\nRAD2EDG = 180 / math.pi   # 常數，弧度轉度數\ntstep = 0.005             # 定義模擬步長\n# 配置關節資訊\njointNum = 6\nbaseName = \'Jaco\'\njointName = \'Jaco_joint\'\nprint(\'Program started\')\n# 關閉潛在的連線\nsim.simxFinish(-1)\n# 每隔0.2s檢測一次，直到連線上V-rep\nwhile True:\n    clientID = sim.simxStart(\'127.0.0.1\', 19999, True, True, 5000, 5)\n    if clientID > -1:\n        print (\'Connected to remote API server\')\n        break\n    else:\n        time.sleep(0.2)\n        print("Failed connecting to remote API server!")\nprint("Connection success!")\n# 設定模擬步長，為了保持API端與V-rep端相同步長\nsim.simxSetFloatingParameter(clientID, sim.sim_floatparam_simulation_time_step, tstep, sim.simx_opmode_oneshot)\n# 然後開啟同步模式\nsim.simxSynchronous(clientID, True) \nsim.simxStartSimulation(clientID, sim.simx_opmode_oneshot)\n\n# 然後讀取Base和Joint的控制代碼\njointHandle = np.zeros((jointNum,), dtype=np.int) # 注意是整型\nfor i in range(jointNum):\n    _, returnHandle = sim.simxGetObjectHandle(clientID, jointName + str(i+1), sim.simx_opmode_blocking)\n    jointHandle[i] = returnHandle\n\n_, baseHandle = sim.simxGetObjectHandle(clientID, baseName, sim.simx_opmode_blocking)\n\nprint(\'Handles available!\')\n\n# 然後首次讀取關節的初始值，以streaming的形式\njointConfig = np.zeros((jointNum,))\nfor i in range(jointNum):\n     _, jpos = sim.simxGetJointPosition(clientID, jointHandle[i], sim.simx_opmode_streaming)\n     jointConfig[i] = jpos\n     lastCmdTime=sim.simxGetLastCmdTime(clientID)  # 記錄當前時間\nsim.simxSynchronousTrigger(clientID)  # 讓模擬走一步\n# 開始模擬\nwhile sim.simxGetConnectionId(clientID) != -1:\n    currCmdTime=sim.simxGetLastCmdTime(clientID)  # 記錄當前時間\n    dt = currCmdTime - lastCmdTime # 記錄時間間隔，用於控制\n    # ***\n    # ***\n    # ***\n    lastCmdTime=currCmdTime    # 記錄當前時間\n    sim.simxSynchronousTrigger(clientID)  # 進行下一步\n    sim.simxGetPingTime(clientID)    # 使得該模擬步走完\n            # 讀取當前的狀態值，之後都用buffer形式讀取\n    for i in range(jointNum):\n            _, jpos = sim.simxGetJointPosition(clientID, jointHandle[i], sim.simx_opmode_buffer)\n            print(round(jpos * RAD2DEG, 2))\n            jointConfig[i] = jpos\n\n    # 控制命令需要同時方式，故暫停通訊，用於儲存所有控制命令一起傳送\n    sim.simxPauseCommunication(clientID, True)\n    for i in range(jointNum):\n            sim.simxSetJointTargetPosition(clientID, jointHandle[i], 120/RAD2DEG, sim.simx_opmode_oneshot)\n            sim.simxPauseCommunication(clientID, False)\n             \n', 'tags': '', 'url': 'RemoteApi.html'}, {'title': 'python', 'text': '各組隨機抽取2個學號並排序 \n import random\n\nwith open("stage3_ag1.txt") as fh:\n    data=fh.readlines()\n\nfor i in range(len(data)):\n    group=data[i].rstrip("\\n").split("\\t")\n    \n    subgroup=group[1:]\n    memberNum=0\n    count =0\n    for j in range(len(subgroup)):\n        if(subgroup[j]!=""):\n            count+=1\n            if(count%2==0):\n                memberNum+=1\n    print("group"+" "+str(i+1)+":"+str(memberNum))\n    beRandomGroup=[]\n    k=0\n    while(k<len(subgroup)):\n        if(subgroup[k]!=""):\n            beRandomGroup.append(subgroup[k])\n        k=k+2\n    var=random.choice(beRandomGroup)\n    while(1==1):\n        var2=random.choice(beRandomGroup)\n        if(var2!=var):\n            break\n    print(var)\n    print(var2)\n    print("---------------------")\n', 'tags': '', 'url': 'python.html'}]};