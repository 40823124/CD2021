var tipuesearch = {"pages": [{'title': 'About', 'text': '\n .. \n', 'tags': '', 'url': 'About.html'}, {'title': 'About me 40823124.', 'text': '\n', 'tags': '', 'url': 'About me 40823124..html'}, {'title': 'Team project', 'text': '', 'tags': '', 'url': 'Team project.html'}, {'title': 'Team1 W2', 'text': 'design a ladder that can move up and down \n \n', 'tags': '', 'url': 'Team1 W2.html'}, {'title': 'Team1 W3', 'text': "Founded that the ladder was too complicated and not feasible in a short time, so changed it to a tank. \n \n control the rotation of the turret \n \n  wheel \n threadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==2007) then\n                    -- up key\n                    velocity=1\n                    torque=2\n                    hammer_back = 0\n\n                    \n                end\n                if (auxiliaryData[1]==2008) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-2\n                     velocity = -1\n\n                end\n               \n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired top position:\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointForce(joint,torque)\n        \n        -- Since this script is threaded, don't waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle('joint1'),sim.getObjectHandle('joint3')\nhammer=sim.getObjectHandle('weel1'),sim.getObjectHandle('weel3')\nvelocity=0\nhammer_back=0\ntorque=0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer,-1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage('Lua runtime error: '..err)\nend\n \n-- Put some clean-up code here:\n\n \n turret \n threadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==97) then\n                    -- a key\n                    velocity=0.01\n                    torque=0.02\n                    hammer_back = 0\n\n                    \n                end\n                if (auxiliaryData[1]==100) then\n                    -- d key\n                     hammer_back = 1\n                     torque=-0.02\n                     velocity = -0.01\n\n                end\n               \n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired top position:\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointForce(joint,torque)\n        \n        -- Since this script is threaded, don't waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle('joint0')\nhammer=sim.getObjectHandle('top')\nvelocity=0\nhammer_back=0\ntorque=0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer,-1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage('Lua runtime error: '..err)\nend\n \n-- Put some clean-up code here:\n\nthreadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==97) then\n                    -- a key\n                    velocity=0.01\n                    torque=0.02\n                    hammer_back = 0\n\n                    \n                end\n                if (auxiliaryData[1]==100) then\n                    -- d key\n                     hammer_back = 1\n                     torque=-0.02\n                     velocity = -0.01\n\n                end\n               \n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired top position:\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointForce(joint,torque)\n        \n        -- Since this script is threaded, don't waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle('joint0')\nhammer=sim.getObjectHandle('top')\nvelocity=0\nhammer_back=0\ntorque=0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer,-1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage('Lua runtime error: '..err)\nend\n \n-- Put some clean-up code here:\n\n \n", 'tags': '', 'url': 'Team1 W3.html'}, {'title': 'coppeliasim', 'text': '', 'tags': '', 'url': 'coppeliasim.html'}, {'title': 'RemoteApi', 'text': 'I try to make a remoteapi(python) of coppeliasim to control the example of robot But it just start simulation, and I cannot control the movement of the model as I set it up. \n \n To use the remote API functionality in python script, need following 3 items: sim.py simConst.py remoteApi.dill ,it can ce found in coppeliasim->programming->remoteapibindings->python , just put all of then in to a same folder. \n \n code \n from __future__ import division\nimport numpy as np\nimport math\nimport sim\n\nRAD2EDG = 180 / math.pi   # 常數，弧度轉度數\ntstep = 0.005             # 定義模擬步長\n# 配置關節資訊\njointNum = 6\nbaseName = \'Jaco\'\njointName = \'Jaco_joint\'\nprint(\'Program started\')\n# 關閉潛在的連線\nsim.simxFinish(-1)\n# 每隔0.2s檢測一次，直到連線上V-rep\nwhile True:\n    clientID = sim.simxStart(\'127.0.0.1\', 19999, True, True, 5000, 5)\n    if clientID > -1:\n        print (\'Connected to remote API server\')\n        break\n    else:\n        time.sleep(0.2)\n        print("Failed connecting to remote API server!")\nprint("Connection success!")\n# 設定模擬步長，為了保持API端與V-rep端相同步長\nsim.simxSetFloatingParameter(clientID, sim.sim_floatparam_simulation_time_step, tstep, sim.simx_opmode_oneshot)\n# 然後開啟同步模式\nsim.simxSynchronous(clientID, True) \nsim.simxStartSimulation(clientID, sim.simx_opmode_oneshot)\n\n# 然後讀取Base和Joint的控制代碼\njointHandle = np.zeros((jointNum,), dtype=np.int) # 注意是整型\nfor i in range(jointNum):\n    _, returnHandle = sim.simxGetObjectHandle(clientID, jointName + str(i+1), sim.simx_opmode_blocking)\n    jointHandle[i] = returnHandle\n\n_, baseHandle = sim.simxGetObjectHandle(clientID, baseName, sim.simx_opmode_blocking)\n\nprint(\'Handles available!\')\n\n# 然後首次讀取關節的初始值，以streaming的形式\njointConfig = np.zeros((jointNum,))\nfor i in range(jointNum):\n     _, jpos = sim.simxGetJointPosition(clientID, jointHandle[i], sim.simx_opmode_streaming)\n     jointConfig[i] = jpos\n     lastCmdTime=sim.simxGetLastCmdTime(clientID)  # 記錄當前時間\nsim.simxSynchronousTrigger(clientID)  # 讓模擬走一步\n# 開始模擬\nwhile sim.simxGetConnectionId(clientID) != -1:\n    currCmdTime=sim.simxGetLastCmdTime(clientID)  # 記錄當前時間\n    dt = currCmdTime - lastCmdTime # 記錄時間間隔，用於控制\n    # ***\n    # ***\n    # ***\n    lastCmdTime=currCmdTime    # 記錄當前時間\n    sim.simxSynchronousTrigger(clientID)  # 進行下一步\n    sim.simxGetPingTime(clientID)    # 使得該模擬步走完\n            # 讀取當前的狀態值，之後都用buffer形式讀取\n    for i in range(jointNum):\n            _, jpos = sim.simxGetJointPosition(clientID, jointHandle[i], sim.simx_opmode_buffer)\n            print(round(jpos * RAD2DEG, 2))\n            jointConfig[i] = jpos\n\n    # 控制命令需要同時方式，故暫停通訊，用於儲存所有控制命令一起傳送\n    sim.simxPauseCommunication(clientID, True)\n    for i in range(jointNum):\n            sim.simxSetJointTargetPosition(clientID, jointHandle[i], 120/RAD2DEG, sim.simx_opmode_oneshot)\n            sim.simxPauseCommunication(clientID, False)\n            ', 'tags': '', 'url': 'RemoteApi.html'}]};