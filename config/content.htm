<h1>About</h1>
<p><img alt="" height="306" src="/images/EUt8sox.gif" width="500"/></p>
<p>..</p>
<h3>About me 40823124.</h3>
<p></p>
<h1>Team project</h1>
<h2>Team1 W2</h2>
<p>design a ladder that can move up and down</p>
<p><img alt="" height="500" src="/images/w2.gif" width="900"/></p>
<h2>Team1 W3</h2>
<p>Founded that the ladder was too complicated and not feasible in a short time, so changed it to a tank.</p>
<p><img alt="" height="500" src="/images/w3.gif" width="900"/></p>
<p>control the rotation of the turret</p>
<p><img alt="" height="550" src="/images/w3_2.gif" width="950"/></p>
<p><br/> wheel</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">threadFunction=function()
    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do
        -- Read the keyboard messages (make sure the focus is on the main window, scene view):
        message,auxiliaryData=sim.getSimulatorMessage()
        while message~=-1 do
            if (message==sim.message_keypress) then
                if (auxiliaryData[1]==2007) then
                    -- up key
                    velocity=1
                    torque=2
                    hammer_back = 0

                    
                end
                if (auxiliaryData[1]==2008) then
                    -- down key
                     hammer_back = 1
                     torque=-2
                     velocity = -1

                end
               
            end
            message,auxiliaryData=sim.getSimulatorMessage()
        end
 
        -- We take care of setting the desired top position:
        sim.setJointTargetPosition(joint, velocity)
        sim.setJointForce(joint,torque)
        
        -- Since this script is threaded, don't waste time here:
        sim.switchThread() -- Resume the script at next simulation loop start
    end
end
-- Put some initialization code here:
-- Retrieving of some handles and setting of some initial values:
joint=sim.getObjectHandle('joint1'),sim.getObjectHandle('joint3')
hammer=sim.getObjectHandle('weel1'),sim.getObjectHandle('weel3')
velocity=0
hammer_back=0
torque=0
orientation=sim.getJointPosition(joint, -1)
position=sim.getObjectPosition(hammer,-1)
-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
    sim.addStatusbarMessage('Lua runtime error: '..err)
end
 
-- Put some clean-up code here:

</pre>
<p>turret</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">threadFunction=function()
    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do
        -- Read the keyboard messages (make sure the focus is on the main window, scene view):
        message,auxiliaryData=sim.getSimulatorMessage()
        while message~=-1 do
            if (message==sim.message_keypress) then
                if (auxiliaryData[1]==97) then
                    -- a key
                    velocity=0.01
                    torque=0.02
                    hammer_back = 0

                    
                end
                if (auxiliaryData[1]==100) then
                    -- d key
                     hammer_back = 1
                     torque=-0.02
                     velocity = -0.01

                end
               
            end
            message,auxiliaryData=sim.getSimulatorMessage()
        end
 
        -- We take care of setting the desired top position:
        sim.setJointTargetPosition(joint, velocity)
        sim.setJointForce(joint,torque)
        
        -- Since this script is threaded, don't waste time here:
        sim.switchThread() -- Resume the script at next simulation loop start
    end
end
-- Put some initialization code here:
-- Retrieving of some handles and setting of some initial values:
joint=sim.getObjectHandle('joint0')
hammer=sim.getObjectHandle('top')
velocity=0
hammer_back=0
torque=0
orientation=sim.getJointPosition(joint, -1)
position=sim.getObjectPosition(hammer,-1)
-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
    sim.addStatusbarMessage('Lua runtime error: '..err)
end
 
-- Put some clean-up code here:

threadFunction=function()
    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do
        -- Read the keyboard messages (make sure the focus is on the main window, scene view):
        message,auxiliaryData=sim.getSimulatorMessage()
        while message~=-1 do
            if (message==sim.message_keypress) then
                if (auxiliaryData[1]==97) then
                    -- a key
                    velocity=0.01
                    torque=0.02
                    hammer_back = 0

                    
                end
                if (auxiliaryData[1]==100) then
                    -- d key
                     hammer_back = 1
                     torque=-0.02
                     velocity = -0.01

                end
               
            end
            message,auxiliaryData=sim.getSimulatorMessage()
        end
 
        -- We take care of setting the desired top position:
        sim.setJointTargetPosition(joint, velocity)
        sim.setJointForce(joint,torque)
        
        -- Since this script is threaded, don't waste time here:
        sim.switchThread() -- Resume the script at next simulation loop start
    end
end
-- Put some initialization code here:
-- Retrieving of some handles and setting of some initial values:
joint=sim.getObjectHandle('joint0')
hammer=sim.getObjectHandle('top')
velocity=0
hammer_back=0
torque=0
orientation=sim.getJointPosition(joint, -1)
position=sim.getObjectPosition(hammer,-1)
-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
    sim.addStatusbarMessage('Lua runtime error: '..err)
end
 
-- Put some clean-up code here:

</pre>
<h2>Team 2</h2>
<p>Programming control mechanicalarm</p>
<p>Used lua api to contral mechanical arm in CoppeliaSim</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/XAc5le46Wso" width="560"></iframe></p>
<p></p>
<p>I edited all joints separately</p>
<p><img alt="" height="398" src="/images/programming.png" width="655"/></p>
<p></p>
<p>This is the parameter of the joint</p>
<p><img alt="" height="398" src="/images/parameter.png" width="650"/></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">threadFunction=function()
    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do
        -- Read the keyboard messages (make sure the focus is on the main window, scene view):
        message,auxiliaryData=sim.getSimulatorMessage()
        while message~=-1 do
            if (message==sim.message_keypress) then
                if (auxiliaryData[1]==97) then
                    -- d key
                    if(o &lt; i*10) then
                    o = o+i
                    velocity=velocity+0.11
                    torque=torque+0.1
                    hammer_back = 0
                    end
                end
                if (auxiliaryData[1]==100) then
                    -- a key 
                    if(o &gt; -i*10) then
                    o = o-i
                    velocity=velocity-0.11
                    torque=torque-0.1
                    hammer_back = 1
                    end
                end
                
            end
            message,auxiliaryData=sim.getSimulatorMessage()
        end
 
        -- We take care of setting the desired hammer position:
        if hammer_back == 1
            then 
               sim.setJointPosition(joint, -1, orientation)
               --sim.setObjectPosition(hammer,-1, position)
        end
        sim.setJointTargetPosition(joint, velocity)
        --sim.setJointForce(joint,torque)

        -- Since this script is threaded, don't waste time here:
        sim.switchThread() -- Resume the script at next simulation loop start
    end
end
-- Put some initialization code here:
-- Retrieving of some handles and setting of some initial values:
i = 1
o = i*1
joint=sim.getObjectHandle('redundantRob_joint1')
hammer=sim.getObjectHandle('Rectangle')
velocity=0
hammer_back=0
torque=0
sliding = 0
orientation=sim.getJointPosition(joint, -1)
position=sim.getObjectPosition(hammer,-1)
-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
    sim.addStatusbarMessage('Lua runtime error: '..err)
end
 
-- Put some clean-up code here:
</pre>
<h2>Difficulties and debugging</h2>
<p>在控制關節時因為每個關節所設置的位置與阻尼參數不同，會有抖動的情形發生，基本上把所有的參數都設成一樣的並把馬達改成控制模式就好了。</p>
<p></p>
<p>再來是程式的部分，因為每個關節都是用速度去控制轉動的，所以為了避免互相影響把每個關節分開單獨用一個子模組控制，而其中設置了轉動條件，限制轉動的次數，且設置了兩個參數控制互鎖，並用自身相加方式達成可以重複接收訊號。</p>
<p></p>
<p>另外在關節2的部分因為承受整隻手臂的絕大重量，所以轉動到了一定角度後會因為自身重量而倒下，所以在關節與程式皆有限制轉動的角度跟輸入次數，當按下按鍵一定次數後必須往反方向轉動，否則互鎖。</p>
<p></p>
<p>參考鍵盤ASCII控制字符</p>
<p><img alt="" height="653" src="/images/ASCII.gif" width="548"/></p>
<h1>coppeliasim</h1>
<h2>RemoteApi</h2>
<p>I try to make a remoteapi(python) of coppeliasim to control the example of robot<br/>But it just start simulation, and I cannot control the movement of the model as I set it up.</p>
<p><img alt="" height="619" src="/images/w5_1.gif" width="1219"/></p>
<p>To use the remote API functionality in python script, need following 3 items:<br/>sim.py simConst.py remoteApi.dill ,it can ce found in coppeliasim-&gt;programming-&gt;remoteapibindings-&gt;python , just put all of then in to a same folder.</p>
<p></p>
<p>code</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">from __future__ import division
import numpy as np
import math
import sim

RAD2EDG = 180 / math.pi   # 常數，弧度轉度數
tstep = 0.005             # 定義模擬步長
# 配置關節資訊
jointNum = 6
baseName = 'Jaco'
jointName = 'Jaco_joint'
print('Program started')
# 關閉潛在的連線
sim.simxFinish(-1)
# 每隔0.2s檢測一次，直到連線上V-rep
while True:
    clientID = sim.simxStart('127.0.0.1', 19999, True, True, 5000, 5)
    if clientID &gt; -1:
        print ('Connected to remote API server')
        break
    else:
        time.sleep(0.2)
        print("Failed connecting to remote API server!")
print("Connection success!")
# 設定模擬步長，為了保持API端與V-rep端相同步長
sim.simxSetFloatingParameter(clientID, sim.sim_floatparam_simulation_time_step, tstep, sim.simx_opmode_oneshot)
# 然後開啟同步模式
sim.simxSynchronous(clientID, True) 
sim.simxStartSimulation(clientID, sim.simx_opmode_oneshot)

# 然後讀取Base和Joint的控制代碼
jointHandle = np.zeros((jointNum,), dtype=np.int) # 注意是整型
for i in range(jointNum):
    _, returnHandle = sim.simxGetObjectHandle(clientID, jointName + str(i+1), sim.simx_opmode_blocking)
    jointHandle[i] = returnHandle

_, baseHandle = sim.simxGetObjectHandle(clientID, baseName, sim.simx_opmode_blocking)

print('Handles available!')

# 然後首次讀取關節的初始值，以streaming的形式
jointConfig = np.zeros((jointNum,))
for i in range(jointNum):
     _, jpos = sim.simxGetJointPosition(clientID, jointHandle[i], sim.simx_opmode_streaming)
     jointConfig[i] = jpos
     lastCmdTime=sim.simxGetLastCmdTime(clientID)  # 記錄當前時間
sim.simxSynchronousTrigger(clientID)  # 讓模擬走一步
# 開始模擬
while sim.simxGetConnectionId(clientID) != -1:
    currCmdTime=sim.simxGetLastCmdTime(clientID)  # 記錄當前時間
    dt = currCmdTime - lastCmdTime # 記錄時間間隔，用於控制
    # ***
    # ***
    # ***
    lastCmdTime=currCmdTime    # 記錄當前時間
    sim.simxSynchronousTrigger(clientID)  # 進行下一步
    sim.simxGetPingTime(clientID)    # 使得該模擬步走完
            # 讀取當前的狀態值，之後都用buffer形式讀取
    for i in range(jointNum):
            _, jpos = sim.simxGetJointPosition(clientID, jointHandle[i], sim.simx_opmode_buffer)
            print(round(jpos * RAD2DEG, 2))
            jointConfig[i] = jpos

    # 控制命令需要同時方式，故暫停通訊，用於儲存所有控制命令一起傳送
    sim.simxPauseCommunication(clientID, True)
    for i in range(jointNum):
            sim.simxSetJointTargetPosition(clientID, jointHandle[i], 120/RAD2DEG, sim.simx_opmode_oneshot)
            sim.simxPauseCommunication(clientID, False)
            </pre>
<h1>python</h1>
<p>各組隨機抽取2個學號並排序</p>
<pre class="brush:python;auto-links:false;toolbar:false" contenteditable="false">import random

with open("stage3_ag1.txt") as fh:
    data=fh.readlines()

for i in range(len(data)):
    group=data[i].rstrip("\n").split("\t")
    
    subgroup=group[1:]
    memberNum=0
    count =0
    for j in range(len(subgroup)):
        if(subgroup[j]!=""):
            count+=1
            if(count%2==0):
                memberNum+=1
    print("group"+" "+str(i+1)+":"+str(memberNum))
    beRandomGroup=[]
    k=0
    while(k&lt;len(subgroup)):
        if(subgroup[k]!=""):
            beRandomGroup.append(subgroup[k])
        k=k+2
    var=random.choice(beRandomGroup)
    while(1==1):
        var2=random.choice(beRandomGroup)
        if(var2!=var):
            break
    print(var)
    print(var2)
    print("---------------------")
</pre>